<!--
    Copyright 2019, Robert L. Read

    This file is part of TriBalance.

    TriBalance is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    TriBalance is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with TriBalance.  If not, see <https://www.gnu.org/licenses/>.
-->

<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <title>TriBalance</title>
    <meta name="description" content="Math and demonstration of a TriBalance diagram represneting attributes in balance such as Mind/Body/Spirit">
    <meta name="author" content="Robert L. Read">

    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">

    <script src="./js/three.js"></script>
    
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">

  <script src="https://code.jquery.com/jquery-1.12.1.js"></script>
  <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>


    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <script src="./js/three.js"></script>
    
    
<body>
  <br>
  <div class="container">
    <h1 class="section-title h1">TriBalance</h1>
    
    <h2>First Three Dimensions</h2>
    <div>
      <button type="button" class="btn btn-primary" id="MBS">Mind/Body/Spirit</button>
      <button type="button" class="btn btn-secondary" id="HHH">Head/Heart/Hands</button>
      <button type="button" class="btn btn-success" id="PSM">Physical/Social/Mental</button>
      <button type="button" class="btn btn-danger" id="SEF">Strength/Endurance/Flexibility</button>
      <button type="button" class="btn btn-warning" id="FSH">Father/Son/Holy Spirit</button>
    </div>
    
    <fieldset>
    <legend>Balancing Norm to Use:</legend>
    <div style="display: flex; justify-content: space-around; font-size: large;">

    <span>
      <label for="l1norm">L1 Norm (Absolute Value):</label>
    <input type="radio" name="norm" id="l1norm" checked="checked">
    </span>
    <span>
    <label for="l2norm">L2 Norm (Sqrt of Squares):</label>
    <input type="radio" name="norm" id="l2norm">
    </span>    
    </div>
    </fieldset>


    <legend>Attributes Calculated from Triangle Position:</legend>
    <div style="display: flex; justify-content: space-around; font-size: x-large; font-weight: bold">
    <div>
      <label for="d0" id="d0l">Mind: </label>
    <span type="text" id="d0">0%</span>
    </div>
    <div>    
      <label for="d1" id="d1l">Body: </label>
    <span type="text" id="d1">0%</span>
    </div>    
    <div>    
      <label for="d2" id="d2l">Spirit: </label>
    <span type="text" id="d2">0%</span>
    </div>    
    </div>

</section>

<div style="display:flex; justify-content: center">
    <div id="container_to_have_global_coords_on_svg">
        <svg id="create_svg"  height="500px" width="500px" style="background: silver;" viewbox="-250 -250 500 500"> </svg>
    </div>
</div>
<section>
  <h1>
    TriBalance Diagrams
</h1>
    <p>
    This is an explanation of what may be a new graphical user interface element---the "tri-balance" diagram. 
    </p>
    <p>
    This is an <a href="https://github.com/PubInv/TriBalance">open source demonstration project</a> of <a href="https://pubinv.github.io/PubInv/">Public Invention</a>. This grew out of the project <a href="https://github.com/PubInv/https://github.com/PubInv/SocialTetrahedrons">open source demonstration project</a>.
    Altough I searched a good bit, I may have missed a previous implementation if the tri-balance diagram has been implmented previously please inform me at &lt;read.robert@gmail.com&gt;.
  </p>
  <h2>Usage</h2>
    These three
  coordinates are considered "balanced", that is, the position on the triangle specifies them with a
  particular algorithm. The closer to one corner of the triangle you are, the more strongly you reflect that
  attribute. The center of the trinagle reflects all attributes equally--that is, "perfect balance."
  The weights of these attributes will be recorded with your assertion, and displayed (temporarily) below the
  triangle.
  <h2>L1 Norm vs. L2 Norm</h2>
  <p>
    To be able to write algorithms about the similarity or complimentarity of,
    for example, a person to a project in terms of Mind/Body/Spirit balance,
    we need a function to translate a position on the triangle into a mathematical
    object of some kind. We also must be able to invert this function, to
    obtain a position on the triangle from a mathematical object.
  </p>
  <p>
    The most obvious way to do this is to treat a given assertion as a vector
    with dimensions labeled, for example, Mind/Body/Spirit. Then a "balanced"
    vector maybe thought of an any vector of unit length. There are different
    ways to express the length of a vector. The L1 Norm is simply the sum
    of the absolute values, so by choosing that all dimensions sum to 1.0.
  </p>
  <p>
    However, it is also reasonable to use the L2 Norm, which is the "Euclidean distance." This is rather like saying every vector is a point on the surface
    of sphere of radius 1.0.  The components of the L2 Norm will sum to something
    usually greater than 1.0.
  </p>
  <h2>License</h2>
  You are free to reuse this software under the terms
  of the GNU General Public License.
</section>
</div>

</div>

    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>




<!-- This is brings in the math and the norm defintions we need -->
    <script src="./TriBalance.js"></script>

    <script>

var THREE_DIMENSIONS = { "MBS": ["Mind","Body","Spirit"],
                         "HHH": ["Head","Heart","Hands"],
                         "PSM": ["Physical","Social","Mental"],
                         "SEF": ["Strength","Endurance","Flexibility"],
                         "FSH": ["Father","Son","Holy Spirit"]
                       };
var CURRENT_D = "MBS";

var WORLD_TRIANGLE_COORDS;
const W = 500;
const H = 500;

const TRIANGLE_WIDTH = 1;
const TRIANGLE_HEIGHT = Math.sqrt(3)/2;
const SIDE_LENGTH_PIXEL = 300;
const SIDE_LENGTH_HEIGHT = SIDE_LENGTH_PIXEL * TRIANGLE_HEIGHT;
const BASE = -(1/3) * SIDE_LENGTH_HEIGHT;

function get_world_triangle() {
     let wtc = [[-SIDE_LENGTH_PIXEL/2,BASE],
                             [SIDE_LENGTH_PIXEL/2,BASE],
                [0,BASE+SIDE_LENGTH_HEIGHT]];
    return wtc;
}


// These function convert my abstract coordinates
// to canvas coordinates.
function vph(h,y) { return (-y); }
function vpw(w,x) { return (x); }

var ADDED_TET_PROJs = [];

var CUR_TRIANGLE_COORDS;

function append_text(svg,x,y,text) {
    var newText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    newText.setAttributeNS(null,"x",x);      
    newText.setAttributeNS(null,"y",y);   
    newText.appendChild(document.createTextNode(text));
    svg.appendChild(newText);
}


function render_svg() {
    var svg = $("#create_svg")[0];
    $("#create_svg").empty();
    var polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    svg.appendChild(polygon);

    let wtc = WORLD_TRIANGLE_COORDS;

    var array = [ [ vpw(W,wtc[0][0]),vph(H,wtc[0][1]) ], 
                  [ vpw(W,wtc[1][0]),vph(H,wtc[1][1]) ],
                  [ vpw(W,wtc[2][0]),vph(H,wtc[2][1]) ] ];
    
    for (value of array) {
        var point = svg.createSVGPoint();
        point.x = value[0];
        point.y = value[1];
        polygon.points.appendItem(point);
    }
    polygon.style.fill='lemonchiffon';

    

    // These are ugly, they should really be computed from the text.
    // In fact, since this does not change, the whole thing could go into
    // HTML and css more profitably.
    
    append_text(svg,array[2][0]-20,array[2][1]-5,
                THREE_DIMENSIONS[CURRENT_D][2]);
    append_text(svg,array[0][0]-40,array[0][1]+20,
                THREE_DIMENSIONS[CURRENT_D][0]);
    append_text(svg,array[1][0],array[1][1]+20,
                THREE_DIMENSIONS[CURRENT_D][1]
               );
    
    var circle = document.createElementNS("http://www.w3.org/2000/svg", 'circle');
    circle.setAttributeNS(null, 'cx', vpw(W,0));
    circle.setAttributeNS(null, 'cy', vph(H,0));
    circle.setAttributeNS(null, 'r', 2);
    circle.setAttributeNS(null, 'style', 'fill: black; stroke: black; stroke-width: 1px;' );
    svg.appendChild(circle);
    
    function add_triangle(tri,c) {
        if (tri) {
            var polygon = document.createElementNS("http://www.w3.org/2000/svg", 'circle');
            polygon.setAttributeNS(null, 'cx', vpw(W,tri.x));
            polygon.setAttributeNS(null, 'cy', vph(H,tri.y));
            polygon.setAttributeNS(null, 'r', 4);
            polygon.setAttributeNS(null, 'style', 'fill: '+c+'; stroke: '+c+'; stroke-width: 1px;' );
            svg.appendChild(polygon);
            
        }
    }
    ADDED_TET_PROJs.forEach( atp => add_triangle(atp,"red"));

}


function main() {
    render_svg();

    function set_dimension_labels(cur) {
        $("#d0l").text(THREE_DIMENSIONS[cur][0] + ":");
        $("#d1l").text(THREE_DIMENSIONS[cur][1] + ":");
        $("#d2l").text(THREE_DIMENSIONS[cur][2] + ":");
    }
    function set_and_render(cur) {
        CURRENT_D = cur;
        set_dimension_labels(CURRENT_D);
        render_svg();        
    }
    
    $("#MBS").click(() => { set_and_render("MBS");});
    $("#HHH").click(() => { set_and_render("HHH");});
    $("#PSM").click(() => { set_and_render("PSM");});
    $("#SEF").click(() => { set_and_render("SEF");});
    $("#FSH").click(() => { set_and_render("FSH");});
}


function getRadioValue(name) {
    var rates = document.getElementsByName(name);
    var rate_value;
    for(var i = 0; i < rates.length; i++){
        if(rates[i].checked){
            rate_value = i;
        }
    }
    return rate_value;
}


function setBalance(atp) {
    var norm_to_use = (getRadioValue("norm") == 0 ? L1NORM :L2NORM);
    let bal = TriBalance2to3(atp,WORLD_TRIANGLE_COORDS,norm_to_use);

    $( "#d0" ).text( (bal.x * 100).toFixed(0) +  "%" );
    $( "#d1" ).text( (bal.y * 100).toFixed(0) +  "%" );
    $( "#d2" ).text( (bal.z * 100).toFixed(0) +  "%" );
    return [bal.x,bal.y,bal.z];
}

// This is tricky because click events on an SVG
// depend on which object inside the SVG are hit.
// We don't really want to do that, we have
// created a global triangle space. A solution
// that doesn't force us to become dependent on the SVG model
// of objects rendered is to use screen coordinates.
function clicked(evt){
    var br = document.getElementById("container_to_have_global_coords_on_svg").getBoundingClientRect();
    var x = evt.originalEvent.clientX - br.left;
    var y = evt.originalEvent.clientY - br.top;
    // x and y are in the coordinates of the
    // SVG system; we need to convert them
    // to the coordinates of our triangle.
    var yc = -(y + -H/2) ;
    var xc = x + -W/2;
    var triangle_coords = {x: xc,y: yc};

    // Note, we could balance and invert here to make sure we are inside the trianble!
    CUR_TRIANGLE_COORDS = triangle_coords;
    var bal = setBalance(triangle_coords);
    var vec = new THREE.Vector3(bal[0],bal[1],bal[2]);
    
    var norm_to_use = (getRadioValue("norm") == 0 ? L1 :L2);
    var triangle_coords_inside_triangle = invertTriBalance2to3(vec,WORLD_TRIANGLE_COORDS,norm_to_use);

    ADDED_TET_PROJs.push(triangle_coords_inside_triangle);
    render_svg();
}         

$("#container_to_have_global_coords_on_svg").click(clicked);

$( document ).ready(function() {
    
    WORLD_TRIANGLE_COORDS = get_world_triangle();
    
    testAllTriBalance(WORLD_TRIANGLE_COORDS);
    
    main();
});

</script>
</body>
</html>
